{load_file("nrngui.hoc")}
{if(!name_declared("COLOR")){ COLOR=-1}}

NCELL = 86
DIM_CMAES = 50


v_init = -65
tstop = 5

objref pc
pc = new ParallelContext()

objref paramname_list
paramname_list = new List()
objref param_vec



{load_file("../hocfile/read.hoc")}
{load_file("../hocfile/cells.hoc")}
{load_file("../hocfile/connectCells.hoc")}
{load_file("../hocfile/record.hoc")}
{load_file("../hocfile/setStim.hoc")}
{load_file("../hocfile/rcv_info_from_CMA.hoc")}

proc readParamFile(){ local dim, flg, val localobj f, paramname, sf, vec
    strdef filename, line, tmp
    //sprint(filename, "%s/params%02d.txt", DIR_TARGET, paramfile_suf.x(0))
    sprint(filename, "../data/params.txt")
    vec = new Vector()
    f = new File()
    { f.ropen(filename) }
    sf = new StringFunctions()
    dim = 0
    while( f.gets(line) != -1){
	if( sf.tail(line, "#", tmp) == 1){ continue }
	{sscanf(line, "%s\t%*lf\t%*lf\t%lf%*c\n", tmp, &val)}
	paramname = new String(tmp)
	paramname_list.append(paramname)
	vec.append(val)
	dim += 1
    }
    DIM_CMAES = dim
    return vec
}

func evalFitness(){ local sum, scaleFactor, n localobj hoge
    //define fitness function. under construction
    sum = 0.0
    scaleFactor  = 0.3 //temporarily
    
    // calc the fitness here under construction
    
    return sum * scaleFactor
}

proc updateParams(){ local i, idx_start localobj param_vec
    param_vec = $o1
    idx_start = $2
    strdef stmt
    
    for(i = 0; i < DIM_CMAES; i += 1){
	sprint(stmt, paramname_list.o(i).s, param_vec.x(idx_start+1))
	{execute(stmt)}
    }
}

proc execSimulation(){ local i, j, root, fitness, tempfit, flg_cmaes_terminate, num_of_pop_per_procs, dim_cmaes, num_of_targetfile, timestep, log_fitness localobj rcv_pop_vec, send_fit_vec, nullvec, tempvec, vec
    
    num_of_pop_per_procs = $1
    dim_cmaes = $2
    num_of_targetfile = $3
    timestep = $4
    log_fitness = $5
    
    {pc.set_parent_comm()}
    
    receiveInfo()
    
    root = 0
    nullvec = new Vector()
    tempvec = new Vector()
    
    {pc.set_parent_comm()}
    {pc.barrier()}
    
    while(1) {
	{pc.set_parent_comm()}
	
	rcv_pop_vec = new Vector()
	send_fit_vec = new Vector(num_of_pop_per_procs)
	
	pc.scatter_d(nullvec, rcv_pop_vec, dim_cmaes * num_of_pop_per_procs, root)
	
	{pc.set_world_comm()}
	//the number of loop = the number of particle this process has..
	for(i=0; i<num_of_pop_per_procs; i+=1){
	    fitness = 0.0
	    //updatePrams
	    for(j=0; j<num_of_targetfile; j+=1){
		//setIClamp
		//initModel
		pc.psolve(timestep)//timestep = tstop in original file
		tempfit = evalFitness()
		//if fitness converted to log_fitness, write here like below
		if(log_fitness == 1){
		    if(tempfit == 0){
			tempfit = -1e100
		    }else{
			tempfit = log10(tempfit)
		    }
		}
		fitness += tempfit
	    }
	    send_fit_vec.x(i) = fitness
	}
	
	{pc.set_parent_comm()}
	pc.gather_d(send_fit_vec, nullvec, num_of_pop_per_procs, root)
	
	//check whether terminal criterion of cmaes holds
	pc.broadcast(tempvec, root)
	flg_cmaes_terminate = int(tempvec.x(0))
	//flg_cmaes_termination = 1 //for break test, inevitably breaking the loop
	if(flg_cmaes_terminate != 0) {break}
    }
}

proc stopTest(){local break_loop, confirm_scatter, root, counter localobj nullvec, tempvec, sendvec, rcvvec
    tempvec = new Vector()
    nullvec = new Vector()
    sendvec = new Vector(4)
    rcvvec = new Vector()
    break_loop = 0
    confirm_scatter = 0
    root = 0
    counter = 0
    
    while(1){
	printf("infinit loop\n")
	{ pc.set_parent_comm() }
	pc.scatter_d(nullvec, rcvvec, 4, root)
	confirm_scatter = int(rcvvec.x(0))
	if(confirm_scatter!=0){
	    printf("success for scatter %d\n", confirm_scatter)
	}else{
	    printf("fail for scatter\n")
	}
	
	{ pc.set_world_comm() }
	for i=0, 3{
	    sendvec.x(i) = 5.0
	}
	{ pc.set_parent_comm() }
	
	pc.gather_d(sendvec, nullvec, 4, root)
	
	pc.broadcast(tempvec, root)
	break_loop = int(tempvec.x(0))
	if(break_loop!=0){
	    printf("break with broadcast\n")
	    break
	}
	counter += 1
	if(counter > 1000){
	    printf("break with max iter\n")
	    break
	}
    }
}

// {read_settings(NCELL)}
// {makeCells(NCELL)}
// {pc.barrier()}
// {connectCells(NCELL)}
// {pc.barrier()}
//{setStim(NCELL, tstop)}
//{setSpikeRecord(NCELL)}
//{finitialize(v_init)}
//{fcurrent()}
//{pc.set_maxstep(10)}
//{stdinit()}
stopTest()
//{pc.psolve(tstop)}
//{pc.barrier()}
//{writeFiles(pc.id, pc.nhost, NCELL)}
{pc.runworker()}
{pc.done()}
quit()